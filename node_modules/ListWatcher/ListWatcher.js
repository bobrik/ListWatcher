var twitter = require("ntwitter");
var moment  = require("moment");
var async   = require("async");
var _       = require("underscore");


var User   = require("ListWatcher/User");
var Logger = require("ListWatcher/Logger");


module.exports = {

    restartTimer: 0,

    rateLimitTimer: 0,

    config: {
        concurrency              : 100,
        restart_timeout          : 10000,
        followers_wait_timeout   : 100,
        rate_limit_check_timeout : 1000,
        followers_update_timeout : 60000
    },

    loggers: {},

    client: null,

    processing: {},

    templates: {},

    messages: {
        deleted_from  : "You have been removed from list <%= result.name %>",
        deleted_lists : "List <%= result.name %> you are member of has been removed or made private",
        added         : "You have been added to list <%= result.name %>",
        renamed       : "List <%= result.name.from %> you are a member of has been renamed to <%= result.name.to %>"
    },

    getClient: function() {
        if (!this.client) {
            var config  = this.getConfig();
            
            this.client = new twitter({
                consumer_key        : config.consumer_key,
                consumer_secret     : config.consumer_secret,
                access_token_key    : config.access_token_key,
                access_token_secret : config.access_token_secret
            });
        }

        return this.client;
    },

    setConfig: function(config) {
        _.extend(this.config, config);

        this.client = null;
    },

    getConfig: function() {
        return this.config;
    },

    getFollowers: function(callback) {
        var self = this,
            now  = moment(),
            wait = self.getConfig().followers_wait_timeout,
            diff;

        if (!self.followers) {
            self.followers = [];
        }

        if (self.followersRequested) {
            return setTimeout(self.getFollowers.bind(self, callback), wait);
        }

        self.followersRequested = true;

        if (!self.followersUpdateTime) {
            self.followersUpdateTime = 0;
        }

        diff = now.valueOf() - this.followersUpdateTime;

        if (diff > self.getConfig().followers_update_timeout || self.followers.length == 0) {
            self.followersUpdateTime = now.valueOf();

            self.getClient().getFollowersIds(function(error, result) {
                self.followersRequested = false;

                if (error) {
                    return callback(error);
                }

                self.followers = result;

                callback(undefined, self.followers);
            });
        } else {
            self.followersRequested = false;
            callback(undefined, self.followers);
        }
    },

    rateLimitChecker: function() {
        var self = this;

        self.getClient().rateLimitStatus(function(error, result) {
            var checker = self.rateLimitChecker.bind(self),
                timeout = self.getConfig().rate_limit_check_timeout,
                now;

            self.rateLimitTimer = 0;

            if (error) {
                self.getLogger("error").write(error);
            } else {
                now = Math.floor(moment().valueOf() / 1000);
                self.getLogger("activity").write("Remaining hits: " + result.remaining_hits +
                                                 ", " + (result.reset_time_in_seconds - now) +
                                                 " seconds to go");

                if (self.started && result.reset_time_in_seconds > now) {
                    self.started = false;
                    self.scheduleRestart(result.reset_time_in_seconds - now);
                }
            }

            if (self.started) {
                self.rateLimitTimer = setTimeout(checker, timeout);
            }
        });
    },

    start: function() {
        var self = this;

        self.getLogger("activity").write("Started");

        self.started = true;

        if (!self.rateLimitTimer) {
            process.nextTick(self.rateLimitChecker.bind(self));
        }

        self.getFollowers(function(error, followers) {
            if (!self.started) {
                return;
            }

            if (error) {
                self.getLogger("error").write(error);

                if (self.started) {
                    self.getLogger("activity").write("Getting followeres failed, restarting");
                    self.scheduleRestart();
                }

                return;
            }

            var i         = 0;
            var queue     = self.getQueue();
            var restarted = false;

            _.times(queue.concurrency, push);

            function push() {
                if (!self.started) {
                    return;
                }

                if (i == followers.length) {
                    return;
                }

                queue.push({user_id: followers[i++]}, function cb(error) {
                    if (error) {
                        self.getLogger("error").write(error);
                    }

                    self.getLogger("activity").write("COMPLETED " +
                                " (" + i + "/" + followers.length + ")" +
                                " Queue: " + _.keys(self.processing).length);

                    if (self.started) {
                        if (i <= followers.length - 1) {
                            queue.push({user_id: followers[i++]}, cb);
                        } else {
                            if (!restarted) {
                                restarted  = true;
                                self.scheduleRestart();
                            }
                        }
                    }
                });
            }
        });
    },

    scheduleRestart: function(timeout) {
        var self = this;

        if (timeout === undefined) {
            timeout = self.getConfig().restart_timeout;
        }

        if (self.restartTimer) {
            clearTimeout(self.restartTimer);
        }

        self.restartTimer = setTimeout(function() {
            self.restartTimer = 0;
            self.start();
        }, timeout);
    },

    getQueue: function() {
        var self = this;

        if (!self.queue) {
            self.queue = async.queue(function(task, callback) {
                var now     = moment(),
                    already = self.processing[task.user_id];

                if (already) {
                    return callback(undefined, now.valueOf() - already);
                }

                self.processing[task.user_id] = now.valueOf();

                _.each(self.processing, function(time, userId) {
                    if (time + 3600000 < now.valueOf()) {
                        delete self.processing[userId];
                        self.getLogger("activity").write("Removed " + userId + " from processing queue");
                    }
                });

                self.processUser(task.user_id, function(error, result) {
                    delete self.processing[task.user_id];

                    callback(error, result);
                });
            }, self.getConfig().concurrency);
        }

        return self.queue;
    },

    processUser: function(user_id, callback) {
        var self   = this,
            client = self.getClient();

        if (!self.started) {
            return process.nextTick(callback);
        }

        // косяк внутри этой хуйни
        client.getListMemberships(user_id, function(error, result) {
            if (error) {
                return callback(error);
            }

            var user  = User.create(user_id),
                lists = {};

            _.each(result, function(list) {
                lists[list.id_str] = list.full_name;
            });

            user.getLists(function(error, oldLists) {
                if (error) {
                    return callback(error);
                }

                if (oldLists === false) {
                    return user.updateLists(lists, function(error) {
                        callback(error);
                    });
                }

                var result = {
                    added         : {},
                    deleted_from  : {},
                    deleted_lists : {},
                    renamed       : {}
                };

                _.each(lists, function(name, id) {
                    if (oldLists[id]) {
                        if (oldLists[id] != name) {
                            result.renamed[id] = {
                                action : "add",
                                name: {
                                    from   : oldLists[id],
                                    to     : name
                                }
                            };
                        }
                    } else {
                        result.added[id] = {
                            action : "add",
                            name   : name
                        };
                    }
                });

                var checkForDeletion = {};

                _.each(oldLists, function(name, id) {
                    if (!lists[id]) {
                        var screenName = name.substr(name.indexOf("/") + 1),
                            exists     = self.isListExists,
                            callback   = exists.bind(self, screenName, id);

                        checkForDeletion[id] = callback;
                    }
                });

                async.parallel(checkForDeletion, function(error, exists) {
                    var notifier = self.notifyAboutChanges.bind(self);

                    _.each(exists, function(exists, id) {
                        var value = {
                            action : "del",
                            name   : oldLists[id]
                        };

                        if (exists) {
                            result.deleted_from[id]  = value;
                        } else {
                            result.deleted_lists[id] = value;
                        }
                    });

                    notifier(user, oldLists, result, function(error) {
                        if (error) {
                            return callback(error);
                        }

                        user.updateLists(lists, callback);
                    });
                });
            });
        });
    },

    notifyAboutChanges: function(user, listsToWrite, changes, callback) {
        var self   = this,
            client = self.getClient();

        self.getLogger("changes").write(user.getId() + ": " +
                                        JSON.stringify(changes));

        function notifyAboutSimpleAction(type, callback) {
            var keys     = _.keys(changes[type]),
                template = self.getTemplate(type),
                text,
                key;

            if (!keys.length) {
                return callback();
            }

            key  = keys[keys.length - 1];
            text = template({result: changes[type][key]});

            client.newDirectMessage(user.getId(), text, function(error) {
                if (error) {
                    return callback(error);
                }

                if (changes[type][key].action == "add") {
                    listsToWrite[key] = changes[type][key];
                } else if (changes[type][key].action == "del") {
                    delete listsToWrite[key];
                } else {
                    throw new Error("Incorrect action passed: " +
                                    JSON.stringify(changes));
                }

                delete changes[type][key];

                self.getLogger("messages").write("Sent " + text +
                                                 " to " + user.getId());

                notifyAboutSimpleAction(type, callback);
            });
        }

        var notifiers = [
            notifyAboutSimpleAction.bind(self, "added"),
            notifyAboutSimpleAction.bind(self, "deleted_from"),
            notifyAboutSimpleAction.bind(self, "deleted_lists"),
            notifyAboutSimpleAction.bind(self, "renamed")
        ];

        async.series(notifiers, callback);
    },

    getTemplate: function(template) {
        if (!this.templates[template]) {
            this.templates[template] = _.template(this.messages[template]);
        }

        return this.templates[template];
    },

    isListExists: function(screenName, listId, callback) {
        var self = this;

        self.getClient().showList(screenName, listId, function(error) {
            if (error) {
                if (error.statusCode == 404) {
                    return callback(undefined, false);
                }

                self.getLogger("error").write(error);

                return callback(undefined, true);
            }

            return callback(undefined, true);
        });
    },

    getLogger: function(type) {
        if (!this.loggers[type]) {
            this.loggers[type] = Logger.create(type);
        }

        return this.loggers[type];
    },

    create: function(config) {
        var self = Object.create(this);

        if (config) {
            self.setConfig(config);
        }

        return self;
    },

    stop: function() {
        this.started = false;

        this.getLogger("activity").write("Stopping..");

        if (this.restartTimer) {
            clearTimeout(this.restartTimer);
        }
    },

    getProcessSignalHandler: function() {
        if (!this.processSignalHandler) {
            this.processSignalHandler = this.stop.bind(this);
        }

        return this.processSignalHandler;
    }

};
